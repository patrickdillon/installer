package management

import (
	"github.com/openshift/installer/pkg/asset"
	capiaws "github.com/openshift/installer/pkg/asset/capi/aws"
	"github.com/openshift/installer/pkg/asset/installconfig"
	typesaws "github.com/openshift/installer/pkg/types/aws"
	"github.com/pkg/errors"
	"github.com/sirupsen/logrus"
	"k8s.io/client-go/kubernetes"
	"k8s.io/client-go/tools/clientcmd"
)

type Cluster struct {
	FileList []*asset.File
}

var _ asset.WritableAsset = (*Cluster)(nil)

// Name returns the human-friendly name of the asset.
func (c *Cluster) Name() string {
	return "Management Cluster"
}

// Dependencies returns the dependencies for accessing
// the management cluster.
func (c *Cluster) Dependencies() []asset.Asset {
	return []asset.Asset{
		&installconfig.InstallConfig{},
	}
}

// Generate launches the cluster and generates the terraform state file on disk.
func (c *Cluster) Generate(parents asset.Parents) (err error) {
	installConfig := &installconfig.InstallConfig{}
	parents.Get(installConfig)

	ic := installConfig.Config

	config, err := clientcmd.BuildConfigFromFlags(ic.ManagementClusterURL, ic.ManagementClusterKubeconfig)
	if err != nil {
		logrus.Fatal(errors.Wrap(err, "connecting to management cluster"))
	}

	client, err := kubernetes.NewForConfig(config)
	if err != nil {
		return errors.Wrap(err, "creating a Kubernetes client")
	}

	version, err := client.DiscoveryClient.ServerVersion()
	if err != nil {
		return errors.Wrap(err, "getting server version")
	}
	logrus.Infof("Connected to Management Cluster with version: %s", version)

	switch ic.Platform.Name() {
	case typesaws.Name:
		logrus.Info("BUGGIN' AWS")
		capiaws.InitializeProvider(ic.ManagementClusterKubeconfig)
	}

	return nil
}

// Files returns the FileList generated by the asset.
func (c *Cluster) Files() []*asset.File {
	return c.FileList
}

// Load TODO
func (c *Cluster) Load(f asset.FileFetcher) (found bool, err error) {
	return false, nil
}
